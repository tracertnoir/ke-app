#include <enrte.h>
#include <stdio.h>
#include <stdlib.h>
#include <enlog.h>
#include <errno.h>
#include <string.h>

#include <sys/ioctl.h>

#include <hiredis.h>
#include <en-drv-conf.h>

#include <en-drv-user.h>

#include <en-drv.h>
#include <en-drv-private.h>

#define STRCMP_D(A, B) ((A) && (B) ? strcmp((A), (B)) == 0 : 0)

#define RTP_MAXI_LENGTH 4096
#define RTP_SERIAL_TIMEOUT 10


void print_hex_to_ascii(const u_char *payload, int len){
	/* ascii (if printable) */
	const u_char *ch;
	int i;

	ch = payload;
	for(i = 0; i < len; i++) {
		if (isprint(*ch)){
			printf("%c", *ch);
    }
		else{
			printf(".");
    }
		ch++;
	}
	printf("\n");
}

void print_hex_to_ascii_2(const u_char *payload, int len){
  /* ascii (if printable) */
  const u_char *ch;
  int i;
  char b[2] = {0,};
  char buff[2048 * 2];
  memset(buff, 0x00, sizeof(buff));

  for(i = 0; i < len; i++) {
    if (isprint(payload[i])){
      sprintf(b, "%c", payload[i]);
      strcat(buff, b);
    }
    else{
      strcat(buff, ".");
      //printf(".");
    }
    ch++;
  }
  log_debug("%s", buff);
}

void print_hex_ascii_line(const u_char *payload, int len, int offset)
{

  int i;
  int gap;
  const u_char *ch;

  /* offset */
  printf("%05d   ", offset);
  
  /* hex */
  ch = payload;
  for(i = 0; i < len; i++) {
    printf("%02x ", *ch);
    ch++;
    /* print extra space after 8th byte for visual aid */
    if (i == 7)
      printf(" ");
  }
  /* print space to handle line less than 8 bytes */
  if (len < 8)
    printf(" ");
  
  /* fill hex gap with spaces if not full line */
  if (len < 16) {
    gap = 16 - len;
    for (i = 0; i < gap; i++) {
      printf("   ");
    }
  }
  printf("   ");
  
  /* ascii (if printable) */
  ch = payload;
  for(i = 0; i < len; i++) {
    if (isprint(*ch))
      printf("%c", *ch);
    else
      printf(".");
    ch++;
  }

  printf("\n");

return;
}

void print_payload(const u_char *payload, int len)
{

  int len_rem = len;
  int line_width = 16;      /* number of bytes per line */
  int line_len;
  int offset = 0;         /* zero-based offset counter */
  const u_char *ch = payload;

  if (len <= 0)
    return;

  /* data fits on one line */
  if (len <= line_width) {
    print_hex_ascii_line(ch, len, offset);
    return;
  }

  /* data spans multiple lines */
  for ( ;; ) {
    /* compute current line length */
    line_len = line_width % len_rem;
    /* print line */
    print_hex_ascii_line(ch, line_len, offset);
    /* compute total remaining */
    len_rem = len_rem - line_len;
    /* shift pointer to remaining bytes to print */
    ch = ch + line_len;
    /* add offset */
    offset = offset + line_width;
    /* check if we have line width chars or less */
    if (len_rem <= line_width) {
      /* print last line and get out */
      print_hex_ascii_line(ch, len_rem, offset);
      break;
    }
  }

return;
}

void tel_set_com_timeout(driver_t *drv){
	redisReply *reply;

	reply = redisCommand(drv->config->db, "SET %s.TIMEOUT %d", drv->config->app, 1);
	freeReplyObject(reply);

	reply = redisCommand(drv->config->db, "EXPIRE %s.TIMEOUT %d", drv->config->app, RTP_SERIAL_TIMEOUT);
	freeReplyObject(reply);

}

static int _data_in_input_queue(driver_t *drv){
    int bytes = 0;
    ioctl(drv->s, FIONREAD, &bytes);
    return bytes;
}

uint8_t *getstr(uint8_t *src, uint8_t *dst, uint8_t delim)
{
  while(*src)
  {
    if(*src == delim){
      src++;
      break;
    }
    *dst++ = *src++;
  }
  *dst = 0x00;
  return src;
}

int next_code(uint8_t *rsp, int length){
  int idx;

  for(idx = 0; idx < length; idx++){
    if(rsp[idx] == 0x1B){
      return idx;
    }
  }
  return length - 4;
}

const char eqCodes[60][5] = {
    "D$#", "D!$", "D$$", "D!'", "D%'", "D('", "D\"*", "D%*", "D(*" ,"D!-",
    "D!0", "D*1", "D2#", "D-$", "D4$", "D;$", "D-&" , "D4&", "D;&" ,"D-(",
    "D4(", "D;(", "D-*", "D4*", "D;*", "D-,", "D4," , "D;,", "D-1" ,"D51",
    "D=1", "D= ", "DB$", "DB&", "DB(", "DB*", "DB," , "DB.", "DB0" ,"DB2",
    "DI$", "DI&", "DI(", "DI*", "DI,", "DI.", "DI0" , "DI2", "DO$" ,"DO&",
    "DO(", "DO*", "DO,", "DO.", "DO0", "DO2", "D !" , "D=/"};

char eqDatas[60][32] = {0,};
float summaryStepData[64][5] = {0,};
float summaryLottData[64][5] = {0,};

void procSummary(int address, float value){
  // 0 : Min, 1 : Max, 2 : Avg, 3 : Sum, 4 : Cnt
  
  // cnt
  summaryStepData[address][4] = summaryStepData[address][4] + 1;
  summaryLottData[address][4] = summaryLottData[address][4] + 1;
  // sum
  summaryStepData[address][3] = summaryStepData[address][3] + value;
  summaryLottData[address][3] = summaryLottData[address][3] + value;
  // avg
  summaryStepData[address][2] = summaryStepData[address][3] / summaryStepData[address][4];
  summaryLottData[address][2] = summaryLottData[address][3] / summaryStepData[address][4];
  // max
  if(summaryStepData[address][1] < value){
    summaryStepData[address][1] = value;
  }
  if(summaryLottData[address][1] < value){
    summaryLottData[address][1] = value;
  }
  // min
  if(summaryStepData[address][0] > value){
    summaryStepData[address][0] = value;
  }
  else
  {
    if(summaryStepData[address][4] == 1){
      summaryStepData[address][0] = value;    
    }
  }
  if(summaryLottData[address][0] > value){
    summaryLottData[address][0] = value;
  }
  else
  {
    if(summaryLottData[address][4] == 1){
      summaryLottData[address][0] = value;    
    }
  }
}

void mset_step_summary(driver_t *drv){
  redisReply *reply;
  int index = 0;

  for(index = 0; index < 64; index++){
    reply = redisCommand(drv->config->db, "MSET %s.STEP_%d_MIN %f %s.STEP_%d_MAX %f %s.STEP_%d_AVG %f %s.STEP_%d_SUM %f %s.STEP_%d_CNT %f",
      drv->config->app, index, summaryStepData[index][0],
      drv->config->app, index, summaryStepData[index][1],
      drv->config->app, index, summaryStepData[index][2],
      drv->config->app, index, summaryStepData[index][3],
      drv->config->app, index, summaryStepData[index][4]);
    freeReplyObject(reply);
  }

  memset(summaryStepData, 0x00, sizeof(summaryStepData));
}

void mset_lot_summary(driver_t *drv){
  redisReply *reply;
  int index = 0;

  for(index = 0; index < 64; index++){
    reply = redisCommand(drv->config->db, "MSET %s.LOT_%d_MIN %f %s.LOT_%d_MAX %f %s.LOT_%d_AVG %f %s.LOT_%d_SUM %f %s.LOT_%d_CNT %f",
      drv->config->app, index, summaryLottData[index][0],
      drv->config->app, index, summaryLottData[index][1],
      drv->config->app, index, summaryLottData[index][2],
      drv->config->app, index, summaryLottData[index][3],
      drv->config->app, index, summaryLottData[index][4]);
    freeReplyObject(reply);
  }

  memset(summaryLottData, 0x00, sizeof(summaryLottData));
}

void set_db_command(driver_t *drv, uint8_t *key, uint8_t *value){
  redisReply *reply;
  reply = redisCommand(drv->config->db, "SET %s.%s %s", drv->config->app, key, value);
  freeReplyObject(reply);
}

void set_db_ikey_command(driver_t *drv, int key, uint8_t *value){
  redisReply *reply;
  reply = redisCommand(drv->config->db, "SET %s.DATA_%d %s", drv->config->app, key, value);
  freeReplyObject(reply);
}

void insetData(driver_t *drv, uint8_t *code, uint8_t *data)
{
  static int prvStepNum = 0;
  int curStepNum = 0;
  int idx;
  float fdata = 0.0f;

  if(STRCMP_D(code, eqCodes[1])){
    curStepNum = atoi(data);
    if(curStepNum != prvStepNum){
      // Step Summary Db SET
      prvStepNum = curStepNum;
      mset_step_summary(drv);
    }
  }

  if(STRCMP_D(code, eqCodes[2])){
    if(STRCMP_D(data, "END     ")){
      mset_lot_summary(drv);
    }
  }



  for(idx = 0; idx < 58; idx++){
    if(STRCMP_D(code, eqCodes[idx])){
        if(STRCMP_D(code,"D4$")){
          fdata = atof(data);
          if(fdata < 100.0f){
            continue;
          }
        }

        sprintf(eqDatas[idx], "%s", data);
        set_db_ikey_command(drv, idx + 1, data);
        
        // procSummary(idx, atof(data));
        // printf("summary = %d, %s, %f\n", idx, data, atof(data) );
    }
  }
}

int tel_read(driver_t *drv, int usectime){
	int rc;
  uint8_t rsp[RTP_MAXI_LENGTH];
	int idx;
  int next_pos;
  uint8_t code[5], data[1024];

  while(TRUE){
  	do
  	{
  		usleep(1 * 1000);
  		rc = _data_in_input_queue(drv);
  	}while(rc == 0);

    memset(rsp, 0x00, sizeof(rsp));
  	rc = user_receive_msg_tail(drv, rsp, 0x03);

  	if(rc > 0){
      // print_hex_to_ascii_2(rsp, rc);
      // if(rc > 100){
      //   print_hex_to_ascii_2(rsp, rc);
      //   continue;
      // }
      tel_set_com_timeout(drv);

      for(idx = 0; idx < rc; idx++){
        if(rsp[idx] == 0x1B){
          memset(data, 0x00, sizeof(data));
          next_pos = next_code((uint8_t *)rsp + idx + 1, rc - idx) - 3;

          memcpy(code, (uint8_t *)rsp + idx + 1, 3);
          memcpy(data, (uint8_t *)rsp + idx + 1 + 3, next_pos);
          // printf("%s, %s\n", code, data );
          insetData(drv, code, data);
        }
      }

      // log_debug("%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s", 
      //   eqDatas[0],  eqDatas[1],  eqDatas[2],  eqDatas[3],  eqDatas[4],  eqDatas[5],  eqDatas[6],  eqDatas[7],
      //   eqDatas[8],  eqDatas[9],  eqDatas[10], eqDatas[11], eqDatas[12], eqDatas[13], eqDatas[14], eqDatas[15]);

      // log_debug("%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s", 
      //   eqDatas[0],  eqDatas[1],  eqDatas[2],  eqDatas[3],  eqDatas[4],  eqDatas[5],  eqDatas[6],  eqDatas[7],  eqDatas[8],  eqDatas[9], 
      //   eqDatas[10], eqDatas[11], eqDatas[12], eqDatas[13], eqDatas[14], eqDatas[15], eqDatas[16], eqDatas[17], eqDatas[18], eqDatas[19],
      //   eqDatas[20], eqDatas[21], eqDatas[22], eqDatas[23], eqDatas[24], eqDatas[25], eqDatas[26], eqDatas[27], eqDatas[28], eqDatas[29], 
      //   eqDatas[30], eqDatas[31], eqDatas[32], eqDatas[33], eqDatas[34], eqDatas[35], eqDatas[36], eqDatas[37], eqDatas[38], eqDatas[39],
      //   eqDatas[40], eqDatas[41], eqDatas[42], eqDatas[43], eqDatas[44], eqDatas[45], eqDatas[46], eqDatas[47], eqDatas[48], eqDatas[49], 
      //   eqDatas[50], eqDatas[51], eqDatas[52], eqDatas[53], eqDatas[54], eqDatas[55], eqDatas[56], eqDatas[57] );
  	}
  }

	return rc;
}

int init_serial(char *key, driver_config_t *conf){
	
	int idx = 0;
	en_db_get_serial(key, conf);
	return idx;
}

int main(int argc, char *argv[]){
	// argv
	// 1. app_name
	// 2. interface

	driver_t *drv;
	driver_config_t conf;
	int rc;
  char logPath[128];
  

	if( config_line_proc(&conf, argc, argv) == -1){
		fprintf(stderr, "Config failed: %s\n", "not run..");
		return -1;
	}


	rc = init_serial(conf.key, &conf);

	drv = uart_new(conf.dev, conf.bandrate, conf.parity, conf.databit, conf.stopbit, 1000);

	rc = driver_connect(drv);
	if(rc < 0){
		return -1;
	}

	driver_db_init(drv, &conf);

  sprintf(logPath, "/media/mmcblk0p1/%s/", conf.key);
  log_set_path(logPath);
	//log_set_path("/media/mmcblk0p1/S05/");

	drv->debug = TRUE;
  // drv->debug = TRUE;

	while(1){
		tel_read(drv, 10);
	}


	driver_db_free(drv);

	driver_close(drv);

	driver_free(drv);
}
